(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{436:function(s,t,a){"use strict";a.r(t);var e=a(18),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"promise的含义-什么是promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise的含义-什么是promise"}},[s._v("#")]),s._v(" Promise的含义（什么是Promise）")]),s._v(" "),a("ul",[a("li",[s._v("Promise是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。简单来说Promise就是一个容器，里面保存着在未来某个时间才会结束的事件结果，从语法上来说Promise是一个对象，从它可以获取一步操作的消息。promise提供统一的API，各种异步操作都可以用同样的方法处理。")]),s._v(" "),a("li",[s._v("Promise有三种状态：pepending（进行中），fulfilled（已成功），rejected（已失败）。只有异步操作的结果可以决定当前是处于哪种状态，任何其他操作都无法改变这个状态。\n"),a("ul",[a("li",[s._v("一旦状态改变，就不会再变。Promise状态改变只有两种可能：pending => fulfilled 或者 pending => rejected")])])])]),s._v(" "),a("h2",{attrs:{id:"promise的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise的使用"}},[s._v("#")]),s._v(" Promise的使用")]),s._v(" "),a("ul",[a("li",[s._v("Promise是一个构造函数，new Promise返回一个Promise对象，接收一个函数作为参数，该函数有两个函数类型参数，分别是resolve和reject")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" promise "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 异步处理")]),s._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 处理结束后、调用resolve 或 reject")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("ul",[a("li",[s._v("Promise.then\n"),a("ul",[a("li",[s._v("传入两个回调函数，成功时执行onFulfilled，失败时执行onRejected")])])])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// onFulfilled 是用来接收promise成功的值")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// onRejected 是用来接收promise失败的原因")]),s._v("\n  promise"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("onFulfilled"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" onRejected"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h2",{attrs:{id:"promise和callback的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise和callback的区别"}},[s._v("#")]),s._v(" Promise和callback的区别")]),s._v(" "),a("ul",[a("li",[s._v("两者之间的主要区别在于，使用回调方法时，我们通常只是将回调传递给一个函数，该函数将在完成时被调用以获取某些结果。但是，在Promise中，您将回调附加在返回的Promise对象上")])]),s._v(" "),a("h2",{attrs:{id:"async和awate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async和awate"}},[s._v("#")]),s._v(" async和awate")]),s._v(" "),a("ul",[a("li",[s._v("async函数返回的都是Promise对象")]),s._v(" "),a("li",[s._v("会将返回值包装为一个Promise对象")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("async")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("Promise.then 成功的情况对应 await")]),s._v(" "),a("li",[s._v("Promise.catch 异常的情况对应 try...catch")])])])}),[],!1,null,null,null);t.default=n.exports}}]);