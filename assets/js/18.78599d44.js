(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{441:function(a,t,v){"use strict";v.r(t);var e=v(18),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"为何在v-for中用key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为何在v-for中用key"}},[a._v("#")]),a._v(" 为何在v-for中用key")]),a._v(" "),v("ul",[v("li",[a._v("必须用key，且不能使用index和随机数")]),a._v(" "),v("li",[a._v("diff算法通过tag和key来判断，是否是同一个vnode")]),a._v(" "),v("li",[a._v("减少渲染次数，提升渲染性能")])]),a._v(" "),v("h2",{attrs:{id:"vue组件如何通讯-常见"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件如何通讯-常见"}},[a._v("#")]),a._v(" Vue组件如何通讯（常见）")]),a._v(" "),v("ul",[v("li",[a._v("父子组件 props和this.$emit")]),a._v(" "),v("li",[a._v("自定义事件 vue.$on vue.$off vue.$emit（vue = new Vue()）,要即时销毁自定义事件，否则可能造成内存泄漏")]),a._v(" "),v("li",[a._v("vuex")])]),a._v(" "),v("h2",{attrs:{id:"computed有何特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed有何特点"}},[a._v("#")]),a._v(" computed有何特点")]),a._v(" "),v("ul",[v("li",[a._v("有缓存，data不变不会重新计算")]),a._v(" "),v("li",[a._v("合理使用能提高性能")])]),a._v(" "),v("h2",{attrs:{id:"ajax请求应该放在哪个生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ajax请求应该放在哪个生命周期"}},[a._v("#")]),a._v(" ajax请求应该放在哪个生命周期")]),a._v(" "),v("ul",[v("li",[a._v("放在mounted里面，因为js是单线程的，ajax异步获取数据，在dom没有渲染完成之前也是在异步队列中")]),a._v(" "),v("li",[a._v("放在mounted之前没有用，只会让逻辑更加混乱")])]),a._v(" "),v("h2",{attrs:{id:"如何将组件所有的props传递给子组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何将组件所有的props传递给子组件"}},[a._v("#")]),a._v(" 如何将组件所有的props传递给子组件")]),a._v(" "),v("ul",[v("li",[a._v("$props")])]),a._v(" "),v("div",{staticClass:"language-html line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[a._v("  "),v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("User")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("v-bind")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[a._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("$props"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("h2",{attrs:{id:"多个组件有相同的逻辑-如何抽离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多个组件有相同的逻辑-如何抽离"}},[a._v("#")]),a._v(" 多个组件有相同的逻辑，如何抽离")]),a._v(" "),v("ul",[v("li",[a._v("mixin")]),a._v(" "),v("li",[a._v("缺点：\n"),v("ul",[v("li",[a._v("变量来源不明确，不利于阅读")]),a._v(" "),v("li",[a._v("多个mixin肯能会造成变量命名冲突")])])])]),a._v(" "),v("h2",{attrs:{id:"何时要使用异步组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#何时要使用异步组件"}},[a._v("#")]),a._v(" 何时要使用异步组件")]),a._v(" "),v("ul",[v("li",[a._v("加载大组件")]),a._v(" "),v("li",[a._v("路由异步加载")]),a._v(" "),v("li",[a._v("优化性能")])]),a._v(" "),v("h2",{attrs:{id:"何时需要使用keep-alive"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#何时需要使用keep-alive"}},[a._v("#")]),a._v(" 何时需要使用keep-alive")]),a._v(" "),v("ul",[v("li",[a._v("缓存组件，不需要重复渲染")]),a._v(" "),v("li",[a._v("如多个静态tab页的切换")]),a._v(" "),v("li",[a._v("优化性能")])]),a._v(" "),v("h2",{attrs:{id:"vue如何监听数组变化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue如何监听数组变化"}},[a._v("#")]),a._v(" Vue如何监听数组变化")]),a._v(" "),v("ul",[v("li",[a._v("Object.defineProperty不能监听数组")]),a._v(" "),v("li",[a._v("重新定义原型，重写push pop等方法，实现监听")])]),a._v(" "),v("h2",{attrs:{id:"vue为何是异步渲染-nexttick有什么用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue为何是异步渲染-nexttick有什么用"}},[a._v("#")]),a._v(" Vue为何是异步渲染，$nextTick有什么用")]),a._v(" "),v("ul",[v("li",[a._v("异步渲染(合并data修改)，提高渲染性能")]),a._v(" "),v("li",[a._v("$nextTick是在DOM更新完成之后，触发回调")])]),a._v(" "),v("h2",{attrs:{id:"vue常见性能优化方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue常见性能优化方式"}},[a._v("#")]),a._v(" Vue常见性能优化方式")]),a._v(" "),v("ul",[v("li",[a._v("合理的使用v-show 和 v-if")]),a._v(" "),v("li",[a._v("合理使用computed （有缓存，提高计算性能）")]),a._v(" "),v("li",[a._v("v-for时加key，以及避免和v-if同时使用（v-for比v-if有更高的优先级，每次循环都要重新计算v-if消耗性能）")]),a._v(" "),v("li",[a._v("自定义事件，DOM事件及时销毁")]),a._v(" "),v("li",[a._v("合理使用异步组件，在大的第三方组件中使用异步组件")]),a._v(" "),v("li",[a._v("合理使用keep-alive 缓存页面")]),a._v(" "),v("li",[a._v("data层级不要太深，因为data深度监听会一次性遍历完成，太深会导致递归次数很多")]),a._v(" "),v("li",[a._v("使用vue-loader 在开发环境做模版编译")]),a._v(" "),v("li",[a._v("前端通用的性能优化，如图片懒加载")])]),a._v(" "),v("p",[a._v("3.再说一下vue2.x中如何监测数组变化\n使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。")])])}),[],!1,null,null,null);t.default=s.exports}}]);