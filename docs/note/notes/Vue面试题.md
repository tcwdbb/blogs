## 为何在v-for中用key
  - 必须用key，且不能使用index和随机数
  - diff算法通过tag和key来判断，是否是同一个vnode
  - 减少渲染次数，提升渲染性能
## Vue组件如何通讯（常见）
  - 父子组件 props和this.$emit
  - 自定义事件 vue.$on vue.$off vue.$emit（vue = new Vue()）,要即时销毁自定义事件，否则可能造成内存泄漏
  - vuex
## computed有何特点
  - 有缓存，data不变不会重新计算
  - 合理使用能提高性能
## ajax请求应该放在哪个生命周期
  - 放在mounted里面，因为js是单线程的，ajax异步获取数据，在dom没有渲染完成之前也是在异步队列中
  - 放在mounted之前没有用，只会让逻辑更加混乱
## 如何将组件所有的props传递给子组件
  - $props
  ```html
    <User v-bind="$props">
  ```
## 多个组件有相同的逻辑，如何抽离
  - mixin
  - 缺点：
    - 变量来源不明确，不利于阅读
    - 多个mixin肯能会造成变量命名冲突
## 何时要使用异步组件
  - 加载大组件
  - 路由异步加载
  - 优化性能
## 何时需要使用keep-alive
  - 缓存组件，不需要重复渲染
  - 如多个静态tab页的切换
  - 优化性能
## Vue如何监听数组变化
  - Object.defineProperty不能监听数组
  - 重新定义原型，重写push pop等方法，实现监听
## Vue为何是异步渲染，$nextTick有什么用
  - 异步渲染(合并data修改)，提高渲染性能
  - $nextTick是在DOM更新完成之后，触发回调
## Vue常见性能优化方式
  - 合理的使用v-show 和 v-if
  - 合理使用computed （有缓存，提高计算性能）
  - v-for时加key，以及避免和v-if同时使用（v-for比v-if有更高的优先级，每次循环都要重新计算v-if消耗性能）
  - 自定义事件，DOM事件及时销毁
  - 合理使用异步组件，在大的第三方组件中使用异步组件
  - 合理使用keep-alive 缓存页面
  - data层级不要太深，因为data深度监听会一次性遍历完成，太深会导致递归次数很多
  - 使用vue-loader 在开发环境做模版编译
  - 前端通用的性能优化，如图片懒加载

  3.再说一下vue2.x中如何监测数组变化
使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。